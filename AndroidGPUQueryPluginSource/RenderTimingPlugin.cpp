#include "RenderTimingPlugin.h"
#include "Unity/IUnityGraphics.h"

#include <cassert>
#include <cmath>
#include <cstdio>
#include <string>
#include <vector>
// --------------------------------------------------------------------------
// Include headers for the graphics APIs we support
#if 0
#define EXPORT_DLL __declspec(dllexport) //导出dll声明
#else
#define EXPORT_DLL
#endif

#if SUPPORT_OPENGL_UNIFIED
#  if UNITY_IPHONE
#    include <OpenGLES/ES2/gl.h>
#  elif UNITY_ANDROID
#    include <GLES3/gl3.h>
#    define GL_TIME_ELAPSED                   0x88BF
#    define GL_GPU_DISJOINT                   0x8FBB
#  else
#    include "GL/glew.h"
#  endif
#endif

typedef void (*PrintLogCallback)(const char*);
typedef void (*PrintLogErrorCallback)(const char*);
typedef void (*PrintEventTimeCallback)(int, float);//int: eventID . float: time in ms
static PrintLogCallback Log;
static PrintLogErrorCallback LogError;
static PrintEventTimeCallback EventTime;

// Register logging printer function
extern "C" {

    EXPORT_DLL void PrintLog(PrintLogCallback callback) {
        Log = callback;
    }
    EXPORT_DLL void PrintLogError(PrintLogErrorCallback callback) {
        LogError = callback;
    }
    EXPORT_DLL void PrintEventTime(PrintEventTimeCallback callback) {
        EventTime = callback;
    }
}

static IUnityInterfaces* s_UnityInterfaces = NULL;
static IUnityGraphics* s_Graphics = NULL;
static UnityGfxRenderer s_DeviceType = kUnityGfxRendererNull;
static void InitRenderTiming();
// --------------------------------------------------------------------------
// GraphicsDeviceEvent

#if SUPPORT_OPENGL_UNIFIED

static void DoEventGraphicsDeviceGLUnified(UnityGfxDeviceEventType eventType) {
  if (eventType == kUnityGfxDeviceEventInitialize) {
    if (s_DeviceType == kUnityGfxRendererOpenGLES20) {
      ::printf("OpenGLES 2.0 device\n");
    }
    else if(s_DeviceType == kUnityGfxRendererOpenGLES30) {
      ::printf("OpenGLES 3.0 device\n");
    }
#if SUPPORT_OPENGL_CORE
    else if(s_DeviceType == kUnityGfxRendererOpenGLCore) {
      ::printf("OpenGL Core device\n");
      glewExperimental = GL_TRUE;
      glewInit();
      glGetError(); // Clean up error generated by glewInit
    }
#endif
    assert(glGetError() == GL_NO_ERROR);
  }
  else if (eventType == kUnityGfxDeviceEventShutdown) {
  }
}
#endif // SUPPORT_OPENGL_UNIFIED

static void UNITY_INTERFACE_API OnGraphicsDeviceEvent(UnityGfxDeviceEventType eventType) {
  UnityGfxRenderer currentDeviceType = s_DeviceType;

  switch (eventType) {
  case kUnityGfxDeviceEventInitialize: {
      s_DeviceType = s_Graphics->GetRenderer();
      currentDeviceType = s_DeviceType;
      break;
    }

  case kUnityGfxDeviceEventShutdown: {
      s_DeviceType = kUnityGfxRendererNull;
      break;
    }

  case kUnityGfxDeviceEventBeforeReset: {
      break;
    }

  case kUnityGfxDeviceEventAfterReset: {
      break;
    }
  };

  #if SUPPORT_OPENGL_UNIFIED
  if (currentDeviceType == kUnityGfxRendererOpenGLES20 ||
    currentDeviceType == kUnityGfxRendererOpenGLES30 ||
    currentDeviceType == kUnityGfxRendererOpenGLCore) {
    DoEventGraphicsDeviceGLUnified(eventType);
    InitRenderTiming();
  }
  #endif
}

// --------------------------------------------------------------------------
// UnitySetInterfaces

extern "C" void  UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API UnityPluginLoad(IUnityInterfaces* unityInterfaces) {
  s_UnityInterfaces = unityInterfaces;
  s_Graphics = s_UnityInterfaces->Get<IUnityGraphics>();
  s_Graphics->RegisterDeviceEventCallback(OnGraphicsDeviceEvent);

  // Run OnGraphicsDeviceEvent(initialize) manually on plugin load
  OnGraphicsDeviceEvent(kUnityGfxDeviceEventInitialize);
}

extern "C" void UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API UnityPluginUnload() {
  s_Graphics->UnregisterDeviceEventCallback(OnGraphicsDeviceEvent);
}
//----------------------------------------------------------------------------
// Implementation Specific Functions

static const int FRAME_COUNT = 2;
static const int QUERY_COUNT = 50;//call record query function up to 50 times within one frame.
static int _frameCount = 0;
static GLuint _query[QUERY_COUNT * FRAME_COUNT];
static std::vector<int> _eventIDList;

static void InitRenderTiming()
{
    glGenQueries(QUERY_COUNT * FRAME_COUNT, _query);
    GLint disjointOccurred;
    glGetIntegerv(GL_GPU_DISJOINT, &disjointOccurred);  // clear
    _eventIDList.reserve(QUERY_COUNT);
    _eventIDList.clear();
}

static void UNITY_INTERFACE_API BeginTimeQueryEvent(int eventID) {
    //TestLogger("BeginTimeQueryEvent");
    if (s_DeviceType == kUnityGfxRendererNull)
        return;
    for (int index = 0; index < (int)_eventIDList.size(); ++index) 
    {
        if (_eventIDList[index] == eventID) 
        {
            std::string eventIDStr = std::to_string(eventID);
            std::string logOutput = "eventID duplicated." + eventIDStr;
            LogError(logOutput.c_str());
            return;
        }
    }
    // // on disjoint exception, clear query buffer
    // GLint disjointOccurred = false;
    // glGetIntegerv(GL_GPU_DISJOINT, &disjointOccurred);
    // if (disjointOccurred) 
    //     LogError("disjoint exception");

    if (eventID < QUERY_COUNT)
    {
        int writeIndex = (_frameCount % 2) * QUERY_COUNT + eventID;
        glBeginQuery(GL_TIME_ELAPSED, _query[writeIndex]);
        if (glGetError() != GL_NO_ERROR) 
            LogError("glBeginQuery failed.");
        else
            _eventIDList.push_back(eventID);
    } 
    else
        LogError("eventID needs less than QUERY_COUNT which is 50.");
}

static void UNITY_INTERFACE_API EndTimeQueryEvent(int eventID) {
    //TestLogger("EndTimeQueryEvent");
    if (s_DeviceType == kUnityGfxRendererNull)
        return;
    bool isMatched = false;
    for (int index = 0; index < (int)_eventIDList.size(); ++index) 
    {
        if (_eventIDList[index] == eventID) 
        {
            isMatched = true;
            //Log("event matched.");
            break;
        }
    }
    if (isMatched)
    {
        glEndQuery(GL_TIME_ELAPSED);
        if (glGetError() != GL_NO_ERROR) 
            LogError("glEndQuery failed.");
    }
    else 
        LogError("glBeginQuery not call before glEndQuery.");
}
//eventID unused.
static void UNITY_INTERFACE_API PrintTimeQueryEvent(int eventID) {
    //TestLogger("PrintTimeQueryEvent");
    // on disjoint exception, clear query buffer
    GLint disjointOccurred = false;
    glGetIntegerv(GL_GPU_DISJOINT, &disjointOccurred);
    if (disjointOccurred) 
        LogError("disjoint exception");
    if (_frameCount > 1) 
    {
      for (int index = 0; index < (int)_eventIDList.size(); ++index) 
      {
          GLuint available = 0;
          int currentEventID = _eventIDList[index];
          int writeIndex = ((_frameCount + 1) % 2) * QUERY_COUNT + currentEventID;
          glGetQueryObjectuiv(_query[writeIndex], GL_QUERY_RESULT_AVAILABLE, &available);
          if (available) 
          {
              GLuint elapsed_time_ns;
              glGetQueryObjectuiv(_query[writeIndex], GL_QUERY_RESULT, &elapsed_time_ns);
              if (glGetError() == GL_NO_ERROR) 
              {
                  float elapsed_time_m_seconds = elapsed_time_ns / 1e6f;
                  EventTime(currentEventID, elapsed_time_m_seconds);
              } 
              else 
                  LogError("Error reading query result.");
          }
      }
    }

    _eventIDList.clear();
    _frameCount++;
}
//-----------------------------------------------------------------------------
// Register Interfaces

// Register begin time query function
extern "C" UnityRenderingEvent UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API TimeQueryBegin() {
  return BeginTimeQueryEvent;
}
// Register end time query function
extern "C" UnityRenderingEvent UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API TimeQueryEnd() {
  return EndTimeQueryEvent;
}
// Register time query print function
extern "C" UnityRenderingEvent UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API TimeQueryEndFrame() {
  return PrintTimeQueryEvent;
}

